#version 440 core
layout(local_size_x=_NBL_GLSL_WORKGROUP_SIZE_) in;

#include <nbl/builtin/glsl/lod_library/descriptor_set.glsl>
#include <nbl/builtin/glsl/lod_library/structs.glsl>

#define NBL_GLSL_CULLING_LOD_SELECTION_INSTANCE_LOD_INFO_UVEC4_OFFSETS_DESCRIPTOR_QUALIFIERS restrict writeonly
#define NBL_GLSL_CULLING_LOD_SELECTION_INSTANCE_DRAWCALL_INCLUSIVE_COUNTS_DESCRIPTOR_QUALIFIERS restrict writeonly
#define NBL_GLSL_CULLING_LOD_SELECTION_PVS_INSTANCE_DRAWS_DESCRIPTOR_QUALIFIERS restrict writeonly
#define NBL_GLSL_CULLING_LOD_SELECTION_DRAW_COUNTS_TO_SCAN_DESCRIPTOR_BINDING
#include <nbl/builtin/glsl/culling_lod_selection/input_descriptor_set.glsl>

#define NBL_GLSL_CULLING_LOD_SELECTION_PER_VIEW_PER_INSTANCE_DESCRIPTOR_QUALIFIERS restrict writeonly
#define NBL_GLSL_CULLING_LOD_SELECTION_PER_INSTANCE_REDIRECT_ATTRS_DESCRIPTOR_BINDING
#define NBL_GLSL_CULLING_LOD_SELECTION_DRAW_CALLS_DESCRIPTOR_QUALIFIERS restrict writeonly
#define NBL_GLSL_CULLING_LOD_SELECTION_DRAW_CALL_COUNTS_DESCRIPTOR_BINDING
#include <nbl/builtin/glsl/culling_lod_selection/output_descriptor_modifiers.glsl>


uint nbl_glsl_culling_lod_selection_getInstanceCount() // TODO: self define
{
    return 7u;
}

void nbl_glsl_culling_lod_selection_initializePerViewPerInstanceData(out nbl_glsl_PerViewPerInstance_t pvpi, in uint instanceGUID)// {} // TODO
{
    mat4 world;
    world[0] = vec4(1.f,0.f,0.f,0.f);
    world[1] = vec4(0.f,1.f,0.f,0.f);
    world[2] = vec4(0.f,0.f,1.f,0.f);
    world[3] = vec4(0.f,float(instanceGUID)*6.f,0.f,1.f);
    pvpi.mvp = /*TODO: viewProj*/world;
}
void nbl_glsl_culling_lod_selection_finalizePerViewPerInstanceData(inout nbl_glsl_PerViewPerInstance_t pvpi, in uint instanceGUID) {} // TODO

void main()
{
    if (gl_GlobalInvocationID.x==0u)
        dispatchIndirect.instanceRefCountingSortScatter.num_groups_x = 1u;
    else if (gl_GlobalInvocationID.x==1u)
        pvsInstanceDraws.count = 0u;

    // TODO: in the future make the drawcalls to scan be dynamic and indirect
    // clear the instance counts to 0
    for (uint drawID=gl_GlobalInvocationID.x; drawID<drawcallsToScan.dwordOffsets.length(); drawID+=_NBL_GLSL_WORKGROUP_SIZE_)
        nbl_glsl_culling_lod_selection_drawCallSetInstanceCount(drawcallsToScan.dwordOffsets[drawID],0u);
        
    uint outIx = 0u;
    for (uint instanceID=gl_GlobalInvocationID.x; instanceID<nbl_glsl_culling_lod_selection_getInstanceCount(); instanceID+=_NBL_GLSL_WORKGROUP_SIZE_)
    {
        const uint instanceGUID = instanceList.data[instanceID][0u];
        const uint lodTableUvec4Offset = instanceList.data[instanceID][1u];

        nbl_glsl_PerViewPerInstance_t perView;
        nbl_glsl_culling_lod_selection_initializePerViewPerInstanceData(perView,instanceGUID);
        // cull lod_table_t
        const mat2x3 tableAABB =  nbl_glsl_lod_library_Table_getAABB(lodTableUvec4Offset);
        if (false) // TODO
            continue;
        const uint lodCount = nbl_glsl_lod_library_Table_getLoDCount(lodTableUvec4Offset);
        // select lod_t
        uint lodInfoUvec4Offset = 0xffffffffu;
        for (uint lodID=0u; lodID<lodCount; lodID++)
        {
            lodInfoUvec4Offset = nbl_glsl_lod_library_Table_getLoDUvec4Offset(lodTableUvec4Offset,lodID);
            if (lodID==instanceID) // TODO: choose LoD properly
                break;
        }
        // cull the lod_t
        if (lodInfoUvec4Offset==0xffffffffu || false) // TODO: check LoD AABB
            continue;
        outIx = atomicAdd(totalInstanceCountAfterCull,1u);
        nbl_glsl_culling_lod_selection_finalizePerViewPerInstanceData(perView,instanceGUID);
        
        lodInfoUvec4Offsets.data[outIx] = lodInfoUvec4Offset;
        lodDrawcallInclusiveCounts[outIx] = nbl_glsl_lod_library_Info_getDrawcallInfoCount(lodInfoUvec4Offset); // TODO: why do we even write this in this pass?
        // TODO: perViewPerInstance.data[outIx] = perView;
    }
    
    // write from this shader
    // would need to know the absolute count of elements (really hard to know when)
#if 0
    const uint maxOutIx = nbl_glsl_workgroupMax(outIx);
    const uint dispatchGroupBound = min(maxOutIx/_NBL_GLSL_WORKGROUP_SIZE_+1u,0x45u);
    if (gl_LocalInvocationIndex==0u)
        atomicMax(dispatchIndirect.instanceDrawCull.groups_x,);
#endif
}