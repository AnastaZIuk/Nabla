#ifndef _NBL_GLSL_WORKGROUP_SIZE_
#define _NBL_GLSL_WORKGROUP_SIZE_ 256
layout(local_size_x = _NBL_GLSL_WORKGROUP_SIZE_) in;
#endif

#ifndef _NBL_GLSL_EXT_RADIXSORT_INPUT_OUTPUT_SET_DEFINED_
#define _NBL_GLSL_EXT_RADIXSORT_INPUT_OUTPUT_SET_DEFINED_ 0
#endif

#ifndef _NBL_GLSL_EXT_RADIXSORT_INPUT_OUTPUT_BINDING_DEFINED_
#define _NBL_GLSL_EXT_RADIXSORT_INPUT_OUTPUT_BINDING_DEFINED_ 0
#endif

#ifndef _NBL_GLSL_EXT_RADIXSORT_HISTOGRAM_OUTPUT_SET_DEFINED_
#define _NBL_GLSL_EXT_RADIXSORT_HISTOGRAM_OUTPUT_SET_DEFINED_ 0
#endif

#ifndef _NBL_GLSL_EXT_RADIXSORT_HISTOGRAM_OUTPUT_BINDING_DEFINED_
#define _NBL_GLSL_EXT_RADIXSORT_HISTOGRAM_OUTPUT_BINDING_DEFINED_ 1
#endif

#ifndef _NBL_GLSL_EXT_RADIXSORT_INPUT_OUTPUT_DESCRIPTOR_DEFINED_

layout (set = _NBL_GLSL_EXT_RADIXSORT_INPUT_OUTPUT_SET_DEFINED_, binding = _NBL_GLSL_EXT_RADIXSORT_INPUT_OUTPUT_BINDING_DEFINED_, std430) buffer inout_buffer
{
	uvec2 inout_values[];
};

#define _NBL_GLSL_EXT_RADIXSORT_INPUT_OUTPUT_DESCRIPTOR_DEFINED_
#endif

#ifndef _NBL_GLSL_EXT_RADIXSORT_HISTOGRAM_OUTPUT_DESCRIPTOR_DEFINED_

layout (set = _NBL_GLSL_EXT_RADIXSORT_HISTOGRAM_OUTPUT_SET_DEFINED_, binding = _NBL_GLSL_EXT_RADIXSORT_HISTOGRAM_OUTPUT_BINDING_DEFINED_, std430) writeonly buffer histogram_out_buffer
{
	uint histogram_out_values[];
};

#define _NBL_GLSL_EXT_RADIXSORT_HISTOGRAM_OUTPUT_DESCRIPTOR_DEFINED_
#endif

#ifndef _NBL_GLSL_EXT_RADIXSORT_PUSH_CONSTANTS_DEFINED_

layout(push_constant) uniform PushConstants
{
    layout (offset = 0) uint shift;
	layout (offset = 4) uint element_count_total; 
} pc;

#define _NBL_GLSL_EXT_RADIXSORT_PUSH_CONSTANTS_DEFINED_
#endif

// This should be in the algorithm header
#define _NBL_GLSL_SCRATCH_SHARED_SIZE_DEFINED_ (_NBL_GLSL_WORKGROUP_SIZE_ * 2 * 4)
shared uint scratch_shared[_NBL_GLSL_SCRATCH_SHARED_SIZE_DEFINED_];
#define _NBL_GLSL_SCRATCH_SHARED_DEFINED_ scratch_shared

#include <nbl/builtin/glsl/workgroup/ballot.glsl>
#include <nbl/builtin/glsl/limits/numeric.glsl>

uvec2 nbl_glsl_ext_RadixSort_getPaddedData(in uint idx)
{
	uvec2 data = uvec2(UINT_MAX);
	if (idx < pc.element_count_total)
		data = inout_values[idx];

	return data;
}

void nbl_glsl_ext_RadixSort_setData(in uint idx, in uvec2 data)
{
	if (idx < pc.element_count_total)
		inout_values[idx] = data;
}

void nbl_glsl_ext_RadixSort_setHistogram(in uint idx, in uint val)
{
	histogram_out_values[idx] = val;
}

uint nbl_glsl_ext_RadixSort_getScatterIndex(in uint key, in bool is_local_sort)
{
	uint scatter_idx = 0;
	uint local_histogram[NUM_BUCKETS];
	for (int i = 0; i < NUM_BUCKETS; ++i)
	{
		const bool predicate = (i == key);
		nbl_glsl_workgroupBallot(predicate);
		local_histogram[i] = nbl_glsl_workgroupBallotInclusiveBitCount();

		if (predicate)
			scatter_idx = local_histogram[i] - 1;
	}

	uint last_of_wg_idx = min((gl_WorkGroupID.x + 1u) * _NBL_GLSL_WORKGROUP_SIZE_ - 1u, pc.element_count_total - 1u);
	if (is_local_sort && (gl_GlobalInvocationID.x == last_of_wg_idx))
	{
		for (int i = 0; i < NUM_BUCKETS; ++i)
			nbl_glsl_ext_RadixSort_setHistogram(i * gl_NumWorkGroups.x + gl_WorkGroupID.x, local_histogram[i]);

		uint sum = 0;
		scratch_shared[0] = sum;
		for (int i = 1; i < NUM_BUCKETS; ++i)
			scratch_shared[i] = (sum += local_histogram[i - 1]);
	}
	barrier();

	return scatter_idx;
}

uvec2 nbl_glsl_ext_RadixSort_scatter(in uvec2 data, in uint scatter_idx)
{
	scratch_shared[scatter_idx] = data.x;
	scratch_shared[_NBL_GLSL_WORKGROUP_SIZE_ + scatter_idx] = data.y;
	barrier();

	return uvec2(scratch_shared[gl_LocalInvocationIndex], scratch_shared[gl_LocalInvocationIndex + _NBL_GLSL_WORKGROUP_SIZE_]);
}


void main()
{
	uvec2 data = nbl_glsl_ext_RadixSort_getPaddedData(gl_GlobalInvocationID.x);
	uint digit = (data.x >> pc.shift) & 0xf;

	uint scatter_idx = nbl_glsl_ext_RadixSort_getScatterIndex(digit, true);
	uint local_scatter_idx = scratch_shared[digit] + scatter_idx; // Adding scatter index to local offset gives local scatter index!
	memoryBarrier();

	data = nbl_glsl_ext_RadixSort_scatter(data, local_scatter_idx);
	nbl_glsl_ext_RadixSort_setData(gl_GlobalInvocationID.x, data);
}

#if 0
void main()
{
	uint digit = (data.x >> pc.shift) & 0xf;
	
	uint local_scatter_idx = 0;
	uint local_histogram[NUM_BUCKETS];
	for (int i = 0; i < NUM_BUCKETS; ++i)
	{
		const bool predicate = (i == digit);
		nbl_glsl_workgroupBallot(predicate);
		local_histogram[i] = nbl_glsl_workgroupBallotInclusiveBitCount();
	
		if (predicate)
			local_scatter_idx = local_histogram[i] - 1;
	}
	
	uint last_of_wg_idx = min((gl_WorkGroupID.x + 1u) * _NBL_GLSL_WORKGROUP_SIZE_ - 1u, pc.element_count_total - 1u);

	if (gl_GlobalInvocationID.x == last_of_wg_idx)
	{
		for (int i = 0; i < NUM_BUCKETS; ++i)
			nbl_glsl_ext_RadixSort_setHistogram(i * gl_NumWorkGroups.x + gl_WorkGroupID.x, local_histogram[i]);
	
		uint sum = 0;
		scratch_shared[0] = sum;
		for (int i = 1; i < NUM_BUCKETS; ++i)
			scratch_shared[i] = (sum += local_histogram[i - 1]);
	}
	barrier();

	uint local_offset = scratch_shared[digit];
	local_scatter_idx += local_offset;
	memoryBarrier();


	scratch_shared[local_scatter_idx] = data.x;
	scratch_shared[_NBL_GLSL_WORKGROUP_SIZE_ + local_scatter_idx] = data.y;
	barrier();
	
	data = uvec2(scratch_shared[gl_LocalInvocationIndex], scratch_shared[gl_LocalInvocationIndex + _NBL_GLSL_WORKGROUP_SIZE_]);

	// Set data here!
}
#endif