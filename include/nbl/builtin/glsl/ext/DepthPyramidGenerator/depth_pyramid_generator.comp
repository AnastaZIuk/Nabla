#version 430 core

layout(local_size_x = WORKGROUP_X_AND_Y_SIZE, local_size_y = WORKGROUP_X_AND_Y_SIZE) in;

#ifdef STRETCH_MIN
#define REDUCTION_OPERATOR min
#else // PAD_MAX
#define REDUCTION_OPERATOR max
#endif


layout(binding = 0, set = 0) uniform sampler2D sourceTexture;
layout(binding = 1, set = 0, MIP_IMAGE_FORMAT) uniform image2D outMips;


uint decodeMorton2dComponent(in uint x) 
{
    x &= 0x55555555u;
    x = (x ^ (x >>  1u)) & 0x33333333u;
    x = (x ^ (x >>  2u)) & 0x0f0f0f0fu;
#if (WORKGROUP_X_AND_Y_SIZE == 32)
    x = (x ^ (x >>  4u)) & 0x00ff00ffu;
#endif
    return x;
}

uvec2 decodeMorton2d4b(in uint x)
{
    return uvec2(decodeMorton2dComponent(x), decodeMorton2dComponent(x >> 1u));
}

void main()
{
    const uvec2 base = gl_WorkGroupID.xy * gl_WorkGroupSize.xy;
    //const uvec2 morton = nbl_glsl_morton2d_4bit_interleave(gl_LocalInvocationIndex);
    const uvec2 morton = decodeMorton2d4b(gl_LocalInvocationIndex);

    {
        const uvec2 naturalOrder = base + morton;
        #ifdef STRETCH_MIN
        const vec2 uv = (vec2(naturalOrder) + vec2(0.5)) / vec2(gl_NumWorkGroups.xy*gl_WorkGroupSize.xy); 
        #else // PAD MAX
        const vec2 uv = (vec2(naturalOrder) + vec2(0.5)) / vec2(textureSize(sourceTexture, 0));
        #endif
        const vec4 samples = textureGather(sourceTexture, uv); // border color set to far value (or far,near if doing two channel reduction)
        const float reducedVal = REDUCTION_OPERATOR(REDUCTION_OPERATOR(samples[0], samples[1]),REDUCTION_OPERATOR(samples[2], samples[3]));
        imageStore(outMips, ivec2(naturalOrder), vec4(reducedVal, 0.f, 0.f, 0.f));
        //sharedMem[WORKGROUP_SIZE+gl_LocalInvocationIndex] = reducedVal;
    }
}