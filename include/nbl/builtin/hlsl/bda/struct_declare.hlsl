// Copyright (C) 2018-2024 - DevSH Graphics Programming Sp. z O.O.
// This file is part of the "Nabla Engine".
// For conditions of distribution and use, see copyright notice in nabla.h
#ifndef _NBL_BUILTIN_HLSL_BDA_STRUCT_DECLARE_INCLUDED_
#define _NBL_BUILTIN_HLSL_BDA_STRUCT_DECLARE_INCLUDED_

#include "nbl/builtin/hlsl/mpl.hlsl"

namespace nbl
{
namespace hlsl
{
namespace bda
{
// silly utility traits
template<typename T>
struct member_count
{
    NBL_CONSTEXPR_STATIC_INLINE uint32_t value = 0;
};
template<typename T>
NBL_CONSTEXPR uint32_t member_count_v = member_count<T>::value;

template<typename T, int32_t MemberIx>
struct member_type;
template<typename T, int32_t MemberIx>
using member_type_t = typename member_type<T,MemberIx>::type;

// default alignment is the alignment of the type
template<typename T, int32_t MemberIx>
struct member_alignment
{
    NBL_CONSTEXPR_STATIC_INLINE uint32_t value = alignment_of_v<member_type_t<T,MemberIx> >;
};
template<typename T, int32_t MemberIx>
NBL_CONSTEXPR uint32_t member_alignment_v = member_alignment<T,MemberIx>::value;

// the default specialization of the offset assumes scalar layout
template<typename T, int32_t MemberIx>
struct member_offset
{
    // TODO: assert that the custom alignment is no less than the type's natural alignment?
    // first byte past previous member, rounded up to out alignment
    NBL_CONSTEXPR_STATIC_INLINE uint64_t value = mpl::align_up_v<member_offset<T,MemberIx-1>::value+size_of_v<member_type_t<T,MemberIx-1> >,member_alignment_v<T,MemberIx> >;
};
template<typename T>
struct member_offset<T,0>
{
    NBL_CONSTEXPR_STATIC_INLINE uint64_t value = 0;
};
template<typename T, int32_t MemberIx>
NBL_CONSTEXPR uint64_t member_offset_v = member_offset<T,MemberIx>::value;

// stuff needed to compute alignment of the struct properly
#ifdef __HLSL_VERSION
namespace impl
{
template<typename T, uint32_t N>
struct default_alignment
{
    NBL_CONSTEXPR_STATIC_INLINE uint32_t value = mpl::max_v<uint32_t,member_alignment_v<T,N-1>,default_alignment<T,N-1>::value>;
};
// le invalid values
template<typename T>
struct default_alignment<T,0>
{
    NBL_CONSTEXPR_STATIC_INLINE uint32_t value = 0;
};
template<typename T, typename MemberCount=member_count<T> >
NBL_CONSTEXPR uint32_t default_alignment_v = default_alignment<T,MemberCount::value>::value;
}
#endif
}
}
}

// time for some macros!
// need to gen identical struct in HLSL and C++
#if 0
// forward declaration - outside of macro
struct MyStruct;

// TODO: to be generated by a BOOST_PP macro:
// - take template parameters list
// - take partial spec name
// - custom alignas on the struct or not
// - sequence of variable name and type (identifier0,Type0)...(identifierN,TypeN)

template</*T_ARGS*/>
struct ::nbl::hlsl::bda::member_count<MyStruct >
{
	NBL_CONSTEXPR_STATIC_INLINE uint32_t value = 3;
};
template</*T_ARGS*/>
struct ::nbl::hlsl::bda::member_type<MyStruct,0>
{
	using type = float32_t;
};
template</*T_ARGS*/>
struct ::nbl::hlsl::bda::member_type<MyStruct,1>
{
	using type = int32_t;
};
template</*T_ARGS*/>
struct ::nbl::hlsl::bda::member_type<MyStruct,2>
{
	using type = int16_t2;
};
// self alignment
#define NBL_ALIGNAS 8
template<>
struct ::nbl::hlsl::alignment_of<MyStruct >
{
	NBL_CONSTEXPR_STATIC_INLINE uint32_t value = ::nbl::hlsl::conditional_value<NBL_ALIGNAS!=0,uint32_t,NBL_ALIGNAS,::nbl::hlsl::bda::impl::default_alignment_v<MyStruct > >::value;
};
template<>
struct ::nbl::hlsl::size_of<MyStruct >
{
	NBL_CONSTEXPR_STATIC_INLINE uint32_t __last_member_ix_v = ::nbl::hlsl::bda::member_count_v<MyStruct >-1;
	NBL_CONSTEXPR_STATIC_INLINE uint64_t __last_member_offset_v = ::nbl::hlsl::bda::member_offset_v<MyStruct,__last_member_ix_v>;
	NBL_CONSTEXPR_STATIC_INLINE uint64_t __last_member_size_v = ::nbl::hlsl::size_of_v<::nbl::hlsl::bda::member_type_t<MyStruct,__last_member_ix_v> >;
	NBL_CONSTEXPR_STATIC_INLINE uint32_t value = mpl::align_up_v<__last_member_offset_v+__last_member_size_v,alignment_of_v<MyStruct > >;
};
#ifdef __HLSL_VERSION
/*template<T_ARGS>*/
struct MyStruct
{
	[[vk::ext_decorate(spv::DecorationOffset,::nbl::hlsl::bda::member_offset_v<MyStruct,0>)]] float32_t a;
	[[vk::ext_decorate(spv::DecorationOffset,::nbl::hlsl::bda::member_offset_v<MyStruct,1>)]] int32_t b;
	[[vk::ext_decorate(spv::DecorationOffset,::nbl::hlsl::bda::member_offset_v<MyStruct,2>)]] int16_t2 c;
};
template<uint32_t alignment, bool _restrict/*, T_ARGS*/>
struct nbl::hlsl::bda::__ref<MyStruct,alignment,_restrict> : nbl::hlsl::bda::__base_ref<MyStruct,alignment,_restrict>
{
    using base_t = __base_ref<MyStruct,alignment,_restrict>;
    using this_t = __ref<MyStruct,alignment,_restrict>;

	::nbl::hlsl::bda::__ref<float32_t,::nbl::hlsl::mpl::min_v<uint32_t,::nbl::hlsl::bda::member_alignment_v<MyStruct,0>,alignment>,_restrict> a;
	::nbl::hlsl::bda::__ref<int32_t,::nbl::hlsl::mpl::min_v<uint32_t,::nbl::hlsl::bda::member_alignment_v<MyStruct,1>,alignment>,_restrict> b;
	::nbl::hlsl::bda::__ref<int16_t2,::nbl::hlsl::mpl::min_v<uint32_t,::nbl::hlsl::bda::member_alignment_v<MyStruct,2>,alignment>,_restrict> c;

	void __init(const ::nbl::hlsl::spirv::bda_pointer_t<MyStruct > _ptr)
	{
		base_t::__init(_ptr);
		a.__init(::nbl::hlsl::spirv::accessChain<float32_t>(base_t::ptr.value,0));
		b.__init(::nbl::hlsl::spirv::accessChain<int32_t>(base_t::ptr.value,1));
		c.__init(::nbl::hlsl::spirv::accessChain<int16_t2>(base_t::ptr.value,2));
	}
};
#else
/*template<T_ARGS>*/
struct /*alignas(NBL_ALIGNAS)*/ MyStruct
{
	alignas(::nbl::hlsl::bda::member_alignment_v<MyStruct,0>) float32_t a;
	alignas(::nbl::hlsl::bda::member_alignment_v<MyStruct,1>) int32_t b;
	alignas(::nbl::hlsl::bda::member_alignment_v<MyStruct,2>) int16_t2 c;
};
#endif
#endif

#endif