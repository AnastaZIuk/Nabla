#ifndef _@_GUARD_SUFFIX_@_C_ARCHIVE_H_
#define _@_GUARD_SUFFIX_@_C_ARCHIVE_H_

#include "nbl/system/CFileArchive.h"
#include "@NBL_BS_HEADER_FILENAME@"

namespace @_NAMESPACE_@
{
	constexpr std::string_view pathPrefix = "@_BUNDLE_ARCHIVE_ABSOLUTE_PATH_@";
	constexpr bool hasPathPrefix(std::string_view str) { return str.find(pathPrefix) == 0ull; }
	
	std::pair<const uint8_t*, size_t> get_resource_runtime(const std::string& filename);

	class CArchive final : public nbl::system::CFileArchive
	{
		public:
			inline CArchive(nbl::system::logger_opt_smart_ptr&& logger)
				: nbl::system::CFileArchive(nbl::system::path(pathPrefix.data()),std::move(logger), getItemList()) {}
			
		protected:
			file_buffer_t getFileBuffer(const nbl::system::IFileArchive::SListEntry* item) override
			{
					auto found = get_resource_runtime(item->pathRelativeToArchive.string());
					return { const_cast<uint8_t*>(found.first), found.second, nullptr };
			}

			nbl::core::vector<nbl::system::IFileArchive::SListEntry> getItemList()
			{
				static nbl::core::vector<nbl::system::IFileArchive::SListEntry> resources
				{
@_RESOURCES_INIT_LIST_@
				};
				
				return resources;
			}
	};
}

#endif // _@_GUARD_SUFFIX_@_C_ARCHIVE_H_


